<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> okiilemon's blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="okiilemon's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/08/13/prototype/" class="post-title-link">__proto__（隐式原型）与prototype（显式原型）</a></h2><div class="post-info">2015年8月13日</div><div class="post-content"><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a><strong>1. 是什么</strong></h3><ul>
<li><p>显式原型 explicit prototype property：每一个<strong>函数</strong>在创建之后都会拥有一个名为<strong>prototype</strong>的属性，这个属性指向函数的原型对象。<br>Note：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。</p>
<blockquote>
<p>NOTE Function objects created using Function.prototype.bind do not have a prototype property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties. ”—– <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5">ECMA262 15.3.4.5</a></p>
</blockquote>
</li>
<li><p>隐式原型 implicit prototype link：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<strong>proto</strong>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().Note: Object.prototype 这个对象是个例外，它的<strong>proto</strong>值为null</p>
</li>
<li>二者的关系：隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</li>
</ul></div><a href="/2015/08/13/prototype/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/19/javascript-the-core-ec-ecs-ao-vo/" class="post-title-link">JavaScript核心原理（一）执行环境、执行环境栈、变量对象、活动对象</a></h2><div class="post-info">2015年3月19日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><span class="s1">之前在阅读《Javascript高级程序设计》「4.2执行环境及作用域的」时候，对相关的概念理解得并不是非常的透彻，只是懂了大概的意思。后来在看到「闭包」这一节时书中再一次提到了相关的概念，并且这些是充分理解闭包的必要背景知识，于是这一次我不能再略读了，必须彻彻底底地弄明白。啃了两天的相关文章、资料后，算是有一个比较清晰的认识了，现在记录下来，希望可以帮到同样对相关概念不熟悉的同学，也可以用作自己日后的回顾和修正。</span></p>
<p><span class="s1">注：Execution Context 可以被翻译为「执行上下文」或者「 执行环境」，文中可能都会用到，大家记住是一个东西就可以了。</span></p></div><a href="/2015/03/19/javascript-the-core-ec-ecs-ao-vo/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/19/call-by-sharing/" class="post-title-link">JavaScript中值的访问与参数传递问题</a></h2><div class="post-info">2014年12月19日</div><div class="post-content"><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 JavaScript 中数据类型可以分为两类：</p>
<ul>
<li><strong>原始数据类型值</strong> primitive type，比如 Undefined, Null, Boolean, Number, String。</li>
<li><strong>引用类型值</strong>，也就是对象类型 Object type，比如 Object, Array, Function, Date 等。</li>
</ul>
<h3 id="声明变量时不同的内存分配"><a href="#声明变量时不同的内存分配" class="headerlink" title="声明变量时不同的内存分配"></a>声明变量时不同的内存分配</h3><ul>
<li>原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</li>
<li>引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>
</ul></div><a href="/2014/12/19/call-by-sharing/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/11/02/pseudo-element/" class="post-title-link">什么是伪元素:after和:before</a></h2><div class="post-info">2014年11月2日</div><div class="post-content"><p>或许你在很多网页的源码上已经不止一次的见过:before 和 :after了，或者是别人利用伪元素做出各种酷炫效果..看见它俩陌生的面孔是不是有些害怕但又很想征服它们运用在自己的项目中呢？希望读完本篇文章后你就可以和它俩混熟了~</p>
<p>在学会使用伪元素之前，先来了解一下什么是伪元素以及它们的工作原理。</p>
<p>很多时候我们希望实现某种效果或是完成某些工作，但是又不希望破坏HTML的语义化，增加一个标签仅仅是为了去达成我们的目的却和结构完全没关系，一名优秀的前端工程师是绝对不会这么干的。那么这个时候，伪元素就该闪亮登场了~ </p>
<p>首先还是让我们来看看官方对伪元素的定义吧: <a href="http://www.w3.org/TR/selectors/#pseudo-elements"><strong>Pseudo-elements</strong></a><br></div><a href="/2014/11/02/pseudo-element/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">okiilemon</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>