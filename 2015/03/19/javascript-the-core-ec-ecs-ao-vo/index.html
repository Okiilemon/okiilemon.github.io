<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript核心原理（一）执行环境、执行环境栈、变量对象、活动对象 · okiilemon's blog</title><meta name="description" content="JavaScript核心原理（一）执行环境、执行环境栈、变量对象、活动对象 - okiilemon"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="okiilemon's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章列表</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">关于</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript核心原理（一）执行环境、执行环境栈、变量对象、活动对象</h1><div class="post-info">2015年3月19日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><span class="s1">之前在阅读《Javascript高级程序设计》「4.2执行环境及作用域的」时候，对相关的概念理解得并不是非常的透彻，只是懂了大概的意思。后来在看到「闭包」这一节时书中再一次提到了相关的概念，并且这些是充分理解闭包的必要背景知识，于是这一次我不能再略读了，必须彻彻底底地弄明白。啃了两天的相关文章、资料后，算是有一个比较清晰的认识了，现在记录下来，希望可以帮到同样对相关概念不熟悉的同学，也可以用作自己日后的回顾和修正。</span></p>
<p><span class="s1">注：Execution Context 可以被翻译为「执行上下文」或者「 执行环境」，文中可能都会用到，大家记住是一个东西就可以了。</span></p>
<a id="more"></a>
<h2 id="什么是执行环境（Execution-Context）？"><a href="#什么是执行环境（Execution-Context）？" class="headerlink" title="什么是执行环境（Execution Context）？"></a><strong>什么是执行环境（Execution Context）？</strong></h2><p><em>“每当程序的执行流进入到一个可执行的代码时，就进入到了一个<strong>执行环境</strong>中。”</em></p>
<p>执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念<br>可执行代码的类型可以为分为：</p>
<ul>
<li>全局代码：程序载入后的默认环境，是运行在程序级别的代码。</li>
<li>函数代码：当执行流进入一个函数后。</li>
<li>Eval代码：Eval 内部的代码。</li>
</ul>
<h1 id="执行环境栈（Execution-Stack）"><a href="#执行环境栈（Execution-Stack）" class="headerlink" title="执行环境栈（Execution Stack）"></a><strong>执行环境栈（Execution Stack）</strong></h1><p><span class="s1">执行流依次进入的执行环境在逻辑上形成了一个栈，栈的底部永远是全局环境，栈的顶部则是处于活动状态当前的执行环境(浏览器总是执行处于栈顶的上下文)。当执行流进入一个函数时，函数的环境就会被推入这个环境栈中，当函数执行完毕之后，栈将这个执行环境弹出，然后把控制权返回给之前的执行环境。这样实现的原因是由于 Javascript 解释器是单线程的，也就是同一时刻只能发生一件事情，其他等待执行的上下文或事件就会在这个环境栈中排队等待。值得注意的一点是：每次函数的调用都会创建一个执行环境压入栈中，无论是函数内部的函数、还是递归调用等。 </span></p>
<p>我们用数组来表示执行环境栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ECStack = [];</div></pre></td></tr></table></figure></p>
<p>来看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(i === <span class="number">3</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"Well,the current FunctionContext is finished."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span>&#123;</div><div class="line">    foo(++i);</div><div class="line">  &#125;</div><div class="line">&#125;)(<span class="number">1</span>);</div></pre></td></tr></table></figure><br>这个函数会被调用3次，分别是 i = 1,i = 2,i = 3 的时候，每次被调用的时候都会创建一个执行上下文然后压入栈中，执行完毕之后再被弹出，最后将控制权交给栈底的全局环境。当第三次调用 foo 函数也就是 i = 3 时，ECStack 状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ECStack = </div><div class="line">[</div><div class="line">   //栈顶</div><div class="line">   FunctionContext - foo(3);</div><div class="line">   FunctionContext - foo(2);</div><div class="line">   FunctionContext - foo(1);</div><div class="line">   GlobalContext</div><div class="line">   //栈底</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h2 id="变量对象-（Variable-Object）"><a href="#变量对象-（Variable-Object）" class="headerlink" title="变量对象 （Variable Object）"></a><strong>变量对象 （Variable Object）</strong></h2><p><em>每一个执行环境都有一个与之相关的<strong>变量对象</strong>，其中存储着上下文中声明的：</em></p>
<ul>
<li><span class="s1">变量 VariableDeclaration VD</span></li>
<li><span class="s1">函数 FunctionDeclaration FD</span></li>
<li><span class="s1">形式参数 formal parameters</span></li>
</ul>
<p><span class="s1">我们可以用一个对象来表示变量对象：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  // 执行上下文中声明的变量、函数、形式参数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不同执行环境下的变量对象"><a href="#不同执行环境下的变量对象" class="headerlink" title="不同执行环境下的变量对象"></a><strong>不同执行环境下的变量对象</strong></h2><p><span class="s1">变量对象是一个抽象的概念，在进入具体的执行上下文时，变量对象在具体实现上也会有相应地差别。</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AbstractVO (generic behavior of the variable instantiation process)</div><div class="line"></div><div class="line">║</div><div class="line">╠══&gt; GlobalContextVO</div><div class="line">║      </div><div class="line">       (VO === this === global)</div><div class="line">║</div><div class="line">╚══&gt; FunctionContextVO</div><div class="line"></div><div class="line">       (VO === AO, &lt;arguments&gt; object and &lt;formal parameters&gt; are added)</div></pre></td></tr></table></figure>
<h4 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a><strong>全局上下文中的变量对象</strong></h4><p><span class="s1"><em>全局对象是一个在进入任何执行上下文前就创建出来的对象；此对象以单例形式存在；它的属性在程序任何地方都可以直接访问，其生命周期随着程序的结束而终止。</em></span></p>
<p><span class="s1">全局对象的属性在任何地方都可以被访问到，可以通过 this 或者 DOM 中的 Window 对象来访问。<strong>全局对象中的变量对象就是全局对象本身</strong>，理解这一点很重要，正是因为这个原因才使得可以通过全局对象的属性来访问在全局上下文中声明的变量。</span></p>
<h4 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a><strong>函数上下文中的变量对象</strong></h4><p><span class="s1">当函数被调用时，一个特殊的对象——<strong>活动对象</strong>就随之创建了。变量对象通过函数的 arguments 对象来初始化，arguments 对象是活动对象上的属性，包含了以下属性：</span></p>
<ul>
<li><span class="s1">callee 对当前函数的引用</span></li>
<li><span class="s1">length 传入的实参个数</span></li>
<li><span class="s1">properties-indexes 参数对应的索引值，相应的值和实际传入的参数值是共享的，但不并是存储在同一个地方的</span></li>
</ul>
<h2 id="执行环境的具体细节"><a href="#执行环境的具体细节" class="headerlink" title="执行环境的具体细节"></a><strong>执行环境的具体细节</strong></h2><p>我们同样也可以用一个对象来表示执行上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutionContextObj = &#123;</div><div class="line">    scopeChain: &#123; 变量对象（variableObject）+ 所有父执行上下文的变量对象 &#125;, </div><div class="line">    variableObject: &#123; &lt;arguments&gt;对象，内部变量声明和函数声明 &#125;, </div><div class="line">    this:&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每当一个函数被调用的时候，就会随之创建一个执行上下文，在 Javascript 解释器内部处理执行上下文有两个步骤：</p>
<ul>
<li><p>第一步：创建阶段 （在函数调用之后，函数体执行之前），解释器扫描传递给函数的参数或arguments，本地函数声明和本地变量声明，并创建executionContextObj对象。扫描的结果将完成变量对象的创建<br>*创建作用域链 （Scope Chain\</p>
<ul>
<li><p>扫描上下文中声明的形式参数、函数以及变量，并依次填充变量对象的属性</p>
</li>
<li><p><span class="s1">函数的形参：形参作为属性，对应的实参作为值。对于没有实参的形参，值为undefined。</span></p>
</li>
<li><span class="s1">函数声明（FunctionDeclaration FD）:由函数对象创建出相应的名、值，名就是函数名、值就是函数体。如果变量对象已经包含了同名的属性，就会替换掉它的值。</span></li>
<li><span class="s1">变量声明（VariableDeclaration）:属性名是变量名，值初始化为 undefined。如果变量名和已经存在的属性同名，不会影响到同名的属性。</span></li>
<li><p><span class="s1">注意：函数表达式（FunctionExpression FE）不会成为变量对象的属性，也就是说函数表达式不会影响到变量对象。</span></p>
</li>
<li><p>求出上下文“this”的值</p>
</li>
</ul>
</li>
<li><p><span class="s1">第二步：代码执行阶段</span></p>
<ul>
<li><span class="s1">这一阶段就会给第一步中初始值为 undefined 的变量赋上相应的值</span><br>我们来看下面这个例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,z</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;)();</div><div class="line"></div><div class="line">&#125;)(<span class="number">10</span>，<span class="number">20</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>函数调用后，相应的executionContextObj如下：</p>
<p>第一阶段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">executionContextObj = &#123;</div><div class="line">	<span class="attr">scopeChain</span>:&#123;...&#125;,</div><div class="line">	<span class="attr">VO</span>: &#123;</div><div class="line">		<span class="attr">arguments</span>:&#123;</div><div class="line">		    <span class="attr">x</span>:<span class="number">10</span>,</div><div class="line">		    <span class="attr">y</span>:<span class="number">20</span>,</div><div class="line">		    <span class="attr">Z</span>:<span class="literal">undefined</span>,</div><div class="line">		    <span class="attr">length</span>:<span class="number">2</span>,<span class="comment">//这里是实际传入参数的个数</span></div><div class="line">		    callee:pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></div><div class="line">		  &#125;</div><div class="line">	  <span class="title">a</span>:<span class="title">undefined</span>,</div><div class="line">	  <span class="title">b</span>:<span class="title">undefined</span>,</div><div class="line">	  <span class="title">c</span>:<span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">c</span>(<span class="params"></span>)</div><div class="line">	&#125;,</div><div class="line">	<span class="title">this</span>:&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二阶段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">executionContextObj = &#123;</div><div class="line">	<span class="attr">scopeChain</span>:&#123;...&#125;,</div><div class="line">	<span class="attr">VO</span>: &#123;</div><div class="line">		<span class="attr">arguments</span>:&#123;</div><div class="line">		    <span class="attr">x</span>:<span class="number">10</span>,</div><div class="line">		    <span class="attr">y</span>:<span class="number">20</span>,</div><div class="line">		    <span class="attr">Z</span>:<span class="literal">undefined</span>,</div><div class="line">		    <span class="attr">length</span>:<span class="number">2</span>,<span class="comment">//这里是实际传入参数的个数</span></div><div class="line">		    callee:pointer to <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span></div><div class="line">		&#125;</div><div class="line">		<span class="title">a</span>:1,</div><div class="line">		<span class="title">b</span>:<span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">b</span>(<span class="params"></span>),</div><div class="line">		<span class="title">c</span>:<span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">c</span>(<span class="params"></span>)</div><div class="line">	&#125;,</div><div class="line">	<span class="title">this</span>:&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在第二阶段，就会为局部变量 a 、b 赋值，注意到 d 并没有在变量对象中，正如上文中提到的那样，函数表达式是不会影响变量对象的，所以在作用域中任何一个位置引用d都会出现“d is not defined”的错误。</p>
<p>现在你应该非常清楚JS中的变量、函数声明提升是怎么回事了吧。</p>
<p>举个例子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);<span class="comment">//"function"</span></div><div class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">  <span class="built_in">console</span>.log(y);<span class="comment">//undefined 而不是 “y is not defined” ,这就是变量声明提升！</span></div><div class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);<span class="comment">//"number"</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125; </div><div class="line"></div><div class="line">&#125;)()</div></pre></td></tr></table></figure></p>
<p>为什么第一次打印x的类型是函数，第二次打印x的类型又是数字呢。这是因为，根据创建上下文时的规则，函数调用之后会按照顺序依次把函数参数、函数声明、变量声明填充为VO的属性，并且填充变量声明的时候如果同名是不会造成任何影响的，x的值还是函数。</p>
<p>在进入上下文阶段，VO的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  x:pointer to function x()</div><div class="line">&#125;</div><div class="line">//发现var x = 10;</div><div class="line">//如果函数“x”还未定义,则 &quot;x&quot; 的值为undefined, </div><div class="line">//但是，在这个例子中</div><div class="line">//变量声明并不会影响同名的值为函数的x</div></pre></td></tr></table></figure></p>
<p>VO[‘x’] 的值仍未改变<br>在代码执行阶段，VO的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO[&apos;x&apos;] = 10;</div></pre></td></tr></table></figure>
<p>这一阶段，局部变量 x 被赋值，此时之前同名的值为函数的 x 就会被覆盖，大家注意声明和赋值！！第一阶段，局部变量声明同名不会影响；第二阶段局部变量赋值就会产生影响了，毕竟人家是最后赋值的嘛。</p>
<p>最后，再来说说关于变量声明的问题：</p>
<p>在《Javascript高级程序设计》4.2.2一节当中有这么一句话：“如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。” 首先，我们应该先明确一点，<em>使用var关键字是声明变量的唯一方式。如果没有var 的话，例如 a = 5 ，a 就将作为全局对象的一个属性，而不是一个变量。</em></p>
<p>区别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(x); //&quot;x&quot; is not defined</div><div class="line">alert(b); //&quot;undefined</div><div class="line"></div><div class="line">x = 10;</div><div class="line">var y = 20;</div></pre></td></tr></table></figure></p>
<p>进入上下文后第一阶段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  x:10;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>VO 中并没有y的原因是，y 并不是变量。另外还要注意的一点就是，没有通过 var 声明的属性可以通过delete操作符删除，而通过var声明的变量就不可以。</p>
<p>啊，差不多把要说的点都说了，如果大家觉得我总结得不好，可以看看以下几篇原文，然后欢迎讨论指出问题哈。</p>
<p>文章参考：</p>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 1. Execution Contexts.</a> |<a href="http://goddyzhao.tumblr.com/post/10020230352/execution-context" target="_blank" rel="external">中文版</a></li>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 2. Variable object.</a> |<a href="http://goddyzhao.tumblr.com/post/11141710441/variable-object" target="_blank" rel="external">中文版</a></li>
<li><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="external">What is the Execution Context &amp; Stack in JavaScript?</a> | <a href="http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="external">中文版</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2015/08/13/prototype/" class="prev">PREV</a><a href="/2014/12/19/call-by-sharing/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">okiilemon</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>